searchState.loadedDescShard("folding_schemes", 0, "<code>Curve</code> trait is a wrapper around <code>CurveGroup</code> that also …\n<code>Field</code> trait is a wrapper around <code>PrimeField</code> that also …\nFoldingScheme defines trait that is implemented by the …\nTrait with auxiliary methods for multi-folding schemes …\nThe in-circuit variable type for this field.\nThe in-circuit variable type for this curve.\nReturns the argument unchanged.\nconstructs the FoldingScheme instance from the given …\nCalls <code>U::from(self)</code>.\nreturns the last IVC state proof, which can be verified in …\nCreates a new IncomingInstance for the given state, to be …\nCreates a new RunningInstance for the given state, to be …\ndeserialize Self::ProverParam and recover the not …\nreturns the state at the current step\ndeserialize Self::VerifierParam and recover the not …\n<code>Arith</code> is a trait about constraint systems (R1CS, CCS, …\n<code>ArithRelation</code> <em>treats a constraint system as a relation</em> …\n<code>ArithRelationGadget</code> defines the in-circuit counterparts of …\n<code>ArithSampler</code> allows sampling random pairs of witness and …\n<code>ArithSerializer</code> is for serializing constraint systems.\nChecks if the evaluation result is valid. The witness <code>w</code> …\nChecks if witness <code>w</code> and instance <code>u</code> satisfy the constraint …\nReturns the degree of the constraint system\nReturns a dummy witness and instance\nGenerates constraints for enforcing that the evaluation …\nGenerates constraints for enforcing that witness <code>w</code> and …\nEvaluates the constraint system <code>self</code> at witness <code>w</code> and …\nEvaluates the constraint system <code>self</code> at witness <code>w</code> and …\nReturns the number of constraints in the constraint system\nReturns the number of public inputs / public IO / …\nReturns the number of variables in the constraint system\nReturns the number of witnesses / secret inputs in the …\nReturns the bytes that represent the parameters, that is, …\nSamples a random witness and instance that satisfy the …\nReturns a tuple containing (w, x) (witness and public …\nCCS represents the Customizable Constraint Systems …\nvector of matrices\nvector of multisets\nvector of coefficients\nPerform the check of the CCCS instance described at …\nComputes Q(x) = eq(beta, x) * q(x) = eq(beta, x) * \\sum^q …\nComputes q(x) = \\sum^q c_i * \\prod_{j \\in S_i} ( \\sum_{y …\nEvaluates the CCS relation at a given vector of …\nPerform the check of the LCCCS instance described at …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\ns = log(m), dimension of x\nt = |M|, number of matrices\nCCSMatricesVar contains the matrices ‘M’ of the CCS …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEvaluates the R1CS relation at a given vector of variables …\nextracts arkworks ConstraintSystem matrices into …\nextracts the witness and the public inputs from arkworks …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn in-circuit representation of the <code>R1CS</code> struct.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCommitmentScheme defines the vector commitment scheme …\nsame as <code>prove</code> but instead of providing a Transcript to …\nsame as <code>verify</code> but instead of providing a Transcript to …\nIPA implements the Inner Product Argument protocol …\nIPAGadget implements the circuit that verifies an IPA …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVerify the IPA opening proof, K=log2(d), where d is the …\nKZG implements the CommitmentScheme trait for the KZG …\nProverKey defines a similar struct as in …\ncommit implements the CommitmentScheme commit interface, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGroup elements of the form <code>β^i G</code>, for different values of …\nprove implements the CommitmentScheme prove interface, …\nsetup returns the tuple (ProverKey, VerifierKey). For real …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCF1 uses the ScalarField of the given C. CF1 represents …\nCF2 uses the BaseField of the given C. CF2 represents the …\n<code>CycleFoldAugmentationGadget</code> implements methods for folding …\nCycleFoldChallengeGadget computes the RO challenge used …\nRe-export the Nova committed instance as …\nCycleFoldCommittedInstanceVar is the CycleFold …\n<code>CycleFoldConfig</code> controls the behavior of <code>CycleFoldCircuit</code>.\nCycleFoldNIFS is a wrapper on top of Nova’s NIFS, which …\nRe-export the Nova committed instance as …\nIn-circuit representation of the Witness associated to the …\n<code>FIELD_CAPACITY</code> is the maximum number of bits that can be …\nPublic inputs length for the <code>CycleFoldCircuit</code>, which …\nThis is the gadget used in the AugmentedFCircuit to verify …\n<code>N_INPUT_POINTS</code> specifies the number of input points that …\n<code>N_UNIQUE_RANDOMNESSES</code> specifies the number of <em>unique</em> …\n<code>RANDOMNESS_BIT_LENGTH</code> is the maximum bit length of a …\n<code>alloc_points</code> allocates the points that are going to be …\n<code>alloc_randomnesses</code> allocates the randomnesses used as …\n<code>build_circuit</code> creates a new <code>CycleFoldCircuit</code> with <code>self</code> as …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a pair of incoming instance and witness for the …\nhash implements the committed instance hash compatible …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>mark_point_as_public</code> marks a point as public.\n<code>mark_randomness_as_public</code> marks randomness as public.\nCreates a new <code>CycleFoldCommittedInstanceVar</code> from the given …\nExtracts the underlying field elements from …\nThis is a temporary workaround for step 6 (running NIFS.V …\nGadget that interpolates the polynomial from the given …\nGadget that computes the KZG challenges. It also offers …\nFold the field elements in <code>U</code> and <code>u</code> inside the circuit.\nFold the group elements (i.e., commitments) in <code>U</code> and <code>u</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCircuit that implements part of the in-circuit checks …\nCircuit that implements part of the in-circuit checks …\nFolding scheme instances\nConstraint system of the Augmented Function circuit\nCycleFold running instance\nCycleFold running instance\nR1CS of the CycleFold circuit\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKZG challenges\nKZG challenges\npublic params hash\npublic params hash\nHelper for folding verification\ninitial state\ncurrent i-th state\nA generic circuit tailored for the onchain (Ethereum’s …\nFolding scheme instances\nConstraint system of the Augmented Function circuit\nCycleFold running instance\nR1CS of the CycleFold circuit\nCycleFold PedersenParams over C2\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nKZG challenges\npublic params hash\nHelper for folding verification\ninitial state\ncurrent i-th state\nNonNativeAffineVar represents an elliptic curve point in …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>LimbVar</code> represents a single limb of a non-native unsigned …\n<code>NonNativeUintVar</code> represents a non-native unsigned integer …\nAdd two <code>LimbVar</code>s. Returns <code>None</code> if the upper bound of the …\nAdd multiple <code>LimbVar</code>s. Returns <code>None</code> if the upper bound of …\nCompute <code>self + other</code>, without aligning the limbs.\nEnforce that <code>self</code> is congruent to <code>other</code> modulo <code>M::MODULUS</code>.\nEnforce <code>self</code> to be equal to <code>other</code>, where <code>self</code> and <code>other</code> …\nEnforce <code>self</code> to be less than <code>other</code>, where <code>self</code> and <code>other</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert <code>Self</code> to an element in <code>M</code>, i.e., compute …\nMultiply two <code>LimbVar</code>s. Returns <code>None</code> if the upper bound of …\nCompute <code>self * other</code>, without aligning the limbs. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEqEval is a gadget for computing $\\tilde{eq}(a, b) = \\prod_…\nGadget to evaluate eq polynomial. Follows the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nF circuit, the circuit that is being folded\nImplements HyperNova+CycleFold’s IVC, described in …\nConfiguration for HyperNova’s CycleFold circuit\nProving parameters for HyperNova-based IVC\nVerification parameters for HyperNova-based IVC\nHyperNova instances\nWitness for the LCCCS &amp; CCCS, containing the w vector, and …\nCCS of the Augmented Function circuit If ccs is set, it …\nCCS of the Augmented step circuit\nCCS of the Augmented Function circuit\nCycleFold running instance\nProving parameters of the underlying commitment scheme …\nCycleFold CommitmentScheme::ProverParams, over C2\nVerification parameters of the underlying commitment …\nR1CS of the CycleFold circuit\nR1CS of the CycleFold circuit\nProving parameters of the underlying commitment scheme …\nCommitmentScheme::ProverParams over C1\nVerification parameters of the underlying commitment …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes the HyperNova+CycleFold’s IVC for the given …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new CCCS instance for the given state, which …\nCreates a new LCCS instance for the given state, which …\nPoseidon sponge configuration\nPoseidon sponge configuration\nreturns the hash of the public parameters of HyperNova\npublic params hash\nImplements IVC.P of HyperNova+CycleFold\nImplements IVC.V of Hyp.clone()erNova+CycleFold. Notice …\ninitial state\ncurrent i-th state\nCommitted CCS instance\nReturns the argument unchanged.\nReturns the internal representation in the same order as …\nCalls <code>U::from(self)</code>.\n<code>AugmentedFCircuit</code> enhances the original step function <code>F</code>, …\nCommitted CCS instance\nLinearized Committed CCS instance\nProofVar defines a multifolding proof\nReturns the CCS out of the AugmentedFCircuit. Notice that …\nThis method computes the CCS parameters. This is used …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRuns (in-circuit) the NIMFS.V, which outputs the new …\nOnchain Decider, for ethereum use cases\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFolding scheme instances\nIn-circuit representation of the Witness associated to the …\nConstraint system of the Augmented Function circuit\nCycleFold running instance\nR1CS of the CycleFold circuit\nCycleFold PedersenParams over C2\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKZG challenges\npublic params hash\nHelper for folding verification\ninitial state\ncurrent i-th state\nLinearized Committed CCS instance\nReturns the argument unchanged.\nReturns the internal representation in the same order as …\nCalls <code>U::from(self)</code>.\nImplements the Non-Interactive Multi Folding Scheme …\nNIMFSProof defines a multifolding proof\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPerforms the multifolding prover. Given μ LCCCS instances …\nPerforms the multifolding verifier. Given μ LCCCS …\nComputes c from the step 5 in section 5 of HyperNova, …\nCompute g(x) polynomial for the given inputs.\nCompute the arrays of sigma_i and theta_i from step 4 …\nF circuit, the circuit that is being folded\nImplements Nova+CycleFold’s IVC, described in Nova and …\nConfiguration for Nova’s CycleFold circuit\nProving parameters for Nova-based IVC\nVerification parameters for Nova-based IVC\nCycleFold running instance\nProving parameters of the underlying commitment scheme …\nCycleFold CommitmentScheme::ProverParams, over C2\nVerification parameters of the underlying commitment …\nR1CS of the CycleFold circuit\nR1CS of the CycleFold circuit\nProving parameters of the underlying commitment scheme …\nCommitmentScheme::ProverParams over C1\nVerification parameters of the underlying commitment …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nhelper method to get the R1CS for both the …\nhelper method to get the r1cs from the …\nhash_cyclefold implements the committed instance hash …\nInitializes the Nova+CycleFold’s IVC for the given …\nReturns the internal representation in the same order as …\nReturns the internal representation in the same order as …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPoseidon sponge configuration\nPoseidon sponge configuration\nreturns the hash of the public parameters of Nova\npublic params hash\nImplements IVC.P of Nova+CycleFold\nR1CS of the Augmented step circuit\nR1CS of the Augmented Function circuit\nImplements IVC.V of Nov.clone()a+CycleFold. Notice that …\nNova instances\ninitial state\ncurrent i-th state\nImplements Nova’s zero-knowledge layer, as described in …\n<code>AugmentedFCircuit</code> enhances the original step function <code>F</code>, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOnchain Decider, for ethereum use cases\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCircuit that implements part of the in-circuit checks …\nCircuit that implements part of the in-circuit checks …\nFolding scheme instances\nConstraint system of the Augmented Function circuit\nCycleFold running instance\nCycleFold running instance\nR1CS of the CycleFold circuit\nKZG challenges\nKZG challenges\npublic params hash\npublic params hash\nHelper for folding verification\ninitial state\ncurrent i-th state\nOnchain Decider, for ethereum use cases\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFolding scheme instances\nIn-circuit representation of the Witness associated to the …\nConstraint system of the Augmented Function circuit\nCycleFold running instance\nR1CS of the CycleFold circuit\nCycleFold PedersenParams over C2\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKZG challenges\npublic params hash\nHelper for folding verification\ninitial state\ncurrent i-th state\nDefines the NIFS (Non-Interactive Folding Scheme) Gadget …\nDefines the NIFS (Non-Interactive Folding Scheme) trait, …\nNIFS.P. Returns a tuple containing the folded Witness, the …\nNIFS.V. Returns the folded CommittedInstance and the used …\nImplements the constraints for NIFS.V for u and x, since …\nImplements the Non-Interactive Folding Scheme described in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMova’s section 4. Protocol 8 Returns a proof for the …\nMova’s section 4. It verifies the results from the proof …\nChallengeGadget computes the RO challenge used for the …\nImplements the Non-Interactive Folding Scheme described in …\ncompute_T: compute cross-terms T. We use the approach …\nfolds two committed instances with the given r and cmT. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCommittedInstanceVar contains the u, x, cmE and cmW values …\nImplements the circuit that does the checks of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA CommittedInstance in Ova is represented by <code>W</code> or <code>W&#39;</code>. It …\nImplements the NIFS (Non-Interactive Folding Scheme) trait …\nA Witness in Ova is represented by <code>w</code>. It also contains a …\nGiven <code>x</code> (public inputs) and <code>t</code> or <code>e</code> (which we always …\nComputes the E parameter (error terms) for the given R1CS …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the internal representation in the same order as …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerates a new <code>Witness</code> instance from a given witness …\nImplements the circuit that does the checks of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProof from step 1 protocol 6\nImplements the Points vs Line as described in Mova and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCompute a zero-knowledge proof of a Nova IVC proof It …\nVerify a zero-knowledge proof of a Nova IVC proof It …\nThe committed instance of ProtoGalaxy.\nF circuit, the circuit that is being folded\nImplements ProtoGalaxy+CycleFold’s IVC, described in …\nConfiguration for ProtoGalaxy’s CycleFold circuit\nProving parameters for ProtoGalaxy-based IVC\nVerification parameters for ProtoGalaxy-based IVC\nIn-circuit representation of the Witness associated to the …\nCycleFold running instance\nProving parameters of the underlying commitment scheme …\nCycleFold CommitmentScheme::ProverParams, over C2\nVerification parameters of the underlying commitment …\nR1CS of the CycleFold circuit\nR1CS of the CycleFold circuit\nProving parameters of the underlying commitment scheme …\nCommitmentScheme::ProverParams over C1\nVerification parameters of the underlying commitment …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes the ProtoGalaxy+CycleFold’s IVC for the …\nReturns the internal representation in the same order as …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPoseidon sponge configuration\nPoseidon sponge configuration\nreturns the hash of the public parameters of ProtoGalaxy\npublic params hash\nImplements IVC.P of ProtoGalaxy+CycleFold\nR1CS of the Augmented step circuit\nR1CS of the Augmented Function circuit\nImplements IVC.V of ProtoGalaxy+CycleFold\nProtoGalaxy instances\ninitial state\ncurrent i-th state\n<code>AugmentedFCircuit</code> enhances the original step function <code>F</code>, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>INCOMING</code> indicates that the committed instance is an …\n<code>RUNNING</code> indicates that the committed instance is a running …\nOnchain Decider, for ethereum use cases\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFolding scheme instances\nIn-circuit representation of the Witness associated to the …\nConstraint system of the Augmented Function circuit\nCycleFold running instance\nR1CS of the CycleFold circuit\nCycleFold PedersenParams over C2\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKZG challenges\npublic params hash\nHelper for folding verification\ninitial state\ncurrent i-th state\nImplements the protocol described in section 4 of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nimplements the non-interactive Prover from the folding …\nimplements the non-interactive Verifier from the folding …\nConverts a value <code>self</code> into a vector of field elements, …\nConverts a value <code>self</code> into a vector of field elements, …\nThe in-circuit representation of the committed instance.\nThe in-circuit representation of the witness.\nChecks if the committed instance is an incoming instance.\nGenerates constraints to enforce that the committed …\nGenerates constraints to enforce that the committed …\nReturns the commitments contained in the committed …\nReturns the commitments contained in the committed …\nReturns the openings (i.e., the values being committed to …\nReturns the openings (i.e., the values being committed to …\nReturns the public inputs contained in the committed …\n<code>hash</code> implements the committed instance hash compatible …\n<code>hash</code> implements the in-circuit committed instance hash …\nReturns <code>true</code> if the committed instance is an incoming …\nFCircuit defines the trait of the circuit of the F …\ngenerates the constraints for the step of F for the given …\nreturns a new FCircuit instance\nreturns the number of elements in the state of the …\nCustomFCircuit is a circuit that has the number of …\nDummyCircuit is a circuit that has dummy state whose …\nWrapperCircuit is a circuit that wraps any circuit that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn interface for objects that can be absorbed by a …\nAn interface for objects that can be absorbed by a …\n<code>absorb_nonnative</code> is for structs that contain non-native …\n<code>absorb_nonnative</code> is for structs that contain non-native …\n<code>absorb_point</code> is for absorbing points whose <code>BaseField</code> is …\n<code>absorb_point</code> is for absorbing points whose <code>BaseField</code> is …\nget_challenge_nbits returns a field element of size nbits\nreturns the bit representation of the challenge, we use …\n<code>new_with_pp_hash</code> creates a new transcript / sponge with …\n<code>new_with_pp_hash</code> creates a new transcript / sponge with …\nConverts the object into field elements that can be …\nConverts the object into field elements that can be …\nConverts the object into field elements that can be …\nThis Poseidon configuration generator agrees with Circom’…\nThis Poseidon configuration generator produces a Poseidon …\nTiny utility enum that allows to import circuits and wasm …\nReturns the argument unchanged.\nreturns the coordinates of a commitment point. This is …\nCalls <code>U::from(self)</code>.\nFor a given x, returns [1, x^1, x^2, …, x^n-1];\nreturns the hash of the given public parameters of the …\nThis module implements the sum check protocol.\nThis module defines our main mathematical object …\nStores a multilinear polynomial in dense evaluation form.\nConcatenate the evaluation tables of multiple polynomials. …\nEvaluate the dense MLE at the given point\nThe evaluation over {0,1}^<code>num_vars</code>\nReturn the MLE resulting from binding the first variables …\nReturns the argument unchanged.\nConstruct a new polynomial from a list of evaluations …\nConstruct a new polynomial from a list of evaluations …\nReturns the evaluation of the polynomial at a point …\nCalls <code>U::from(self)</code>.\nReturns an iterator that iterates over the evaluations …\nReturns a mutable iterator that iterates over the …\nNumber of variables\nRelabel the point in place by switching <code>k</code> scalars from …\nGiven multilinear polynomial <code>p(x)</code> and s <code>s</code>, compute <code>s*p(x)</code>\nA generic sum-check trait over a curve group\nTrait for sum check protocol prover side APIs.\nA SumCheckSubClaim is a claim generated by the verifier at …\nTrait for sum check protocol verifier side APIs.\nThis function verifies the deferred checks in the …\nthe expected evaluation\nExtract sum from the proof\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nthe multi-dimensional point that this multilinear …\nGenerate proof of the sum of polynomial over {0,1}^<code>num_vars</code>\nReceive message from verifier, generate prover message, …\nInitialize the prover state to argue for the sum of the …\nThis module defines structs that are shared by all sub …\nVerifier subroutines for a SumCheck protocol.\nInitialize the verifier’s state.\nVerify the claimed sum using the proof\nRun verifier for the current round, given a prover message.\nAn IOP proof is a collections of\nA message from the prover to the verifier at a given round …\nProver State of a PolyIOP.\nVerifier State of a PolyIOP, generic over a curve group\nsampled randomness given by the verifier\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReceive message from verifier, generate prover message, …\nInitialize the prover state to argue for the sum of the …\nInitialize the verifier’s state.\nInterpolate a uni-variate degree-<code>p_i.len()-1</code> polynomial …\nA <code>enum</code> specifying the possible failure modes of the …\nAuxiliary information about the multilinear polynomial\nA virtual polynomial is a sum of products of multilinear …\nAdd a product of list of multilinear extensions to self …\nAux information about the multilinear polynomial\nDecompose an integer into a binary vector in little endian.\nThis function build the eq(x, r) polynomial for any given …\nThis function build the eq(x, r) polynomial for any given …\nEvaluate eq polynomial.\nEvaluate the virtual polynomial at point <code>point</code>. Returns an …\nStores multilinear extensions in which product …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nmax number of multiplicands in each product\nMultiple the current VirtualPolynomial by an MLE:\nCreates an empty virtual polynomial with <code>num_variables</code>.\nCreates a new virtual polynomial from a MLE and its …\nnumber of variables of the polynomial\nlist of reference to products (as usize) of multilinear …\nGiven virtual polynomial <code>p(x)</code> and scalar <code>s</code>, compute <code>s*p(x)</code>\n<code>EquivalenceGadget</code> enforces that two in-circuit variables …\nInterprets the given vector v as the evaluations of a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA boolean hypercube that returns its points as an iterator …\nreturns the entry at given i (which is the little-endian …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nComputes the lagrange interpolated polynomial from the …\nTakes the n_vars and a dense vector and returns its dense …\nTakes the n_vars and a dense vector and returns its sparse …\nReturns the dense multilinear extension from the given …\nReturns the sparse multilinear extension from the given …\nPad matrix so that its columns and rows are powers of two\nTakes the n_vars and a dense vector and returns its dense …\nTakes the n_vars and a sparse vector and returns its …\nA sparse representation of constraint matrices.\ncoeffs = R1CSMatrix = Vec&lt;Vec&lt;(F, usize)&gt;&gt;, which contains …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nreturns the interpolated polynomial of …")